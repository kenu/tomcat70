<?xml version="1.0"?>
<!--
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<!DOCTYPE document [
  <!ENTITY project SYSTEM "project.xml">
]>
<document url="source.html">

  &project;

  <properties>
    <author email="craigmcc@apache.org">크레이그 R. 맥클라나한</author>
    <title>원본 구조</title>
  </properties>

<body>

<section name="Table of Contents">
<toc/>
</section>

<section name="Directory Structure">

    <blockquote><em>
    <p>다음 설명은 대부분의 상대 경로가 해결되고 그에 대한 기본 디렉토리를 참조하는 변수 이름으로 $CATALINA_BASE를 사용하고 있습니다. 사용자는 CATALINA_BASE를 설정하여 여러 인스턴스에 Tomcat을 구성하지 않은 경우, 디렉토리의 다음 $ CATALINA_BASE는 $CATALINA_HOME의 값으로 설정됩니다. 이것은 Tomcat을 설치한 디렉터리입니다.</p>
    </em></blockquote>

<p>이 설명서의 주요 권고 사항은 배포 응용 프로그램 (앞에서 설명한)를 포함하는 디렉토리 계층 구조에서 소스 코드를 (이 절에서 설명)를 포함하는 디렉토리 계층을 분리하는 것입니다. 이 분리를 유지하는 것은 다음과 같은 장점이 있습니다.</p>
<ul>
<li>소스 디렉토리의 내용을 보다 쉽게 관리 할 수 있는 이동, "실행 가능한" 응용 프로그램 버전이 혼합되지 않은 경우 백업할 수 있습니다.
    <br/><br/></li>
<li>소스 코드 관리, 소스 파일이 있는 디렉토리의 관리가 용이합니다.
    <br/><br/></li>
<li>응용 프로그램 설치 가능한 배포판을 구성하는 파일은 배포 계층이 다른 때 선택하는 것이 훨씬 쉽습니다.</li>
</ul>

<p>우리가 본대로, <code> ant </code>의 개발 도구는 이러한 디렉터리 계층 생성 및 처리가 거의 고통에 가깝습니다.</p>

<p>응용 프로그램의 소스 코드를 저장하는 데 사용되는 실제 디렉터리 및 파일 계층이 좋지만은 않다는 것입니다. 그러나 다음의 조직은 매우 일반적으로 적용 가능한 것으로 판명되어, 예를 들면 이 <code> build.xml </code> 가 아래에 설명된 구성 파일이 됩니다. 이러한 모든 구성 요소는 응용 프로그램의 최상위 <em> 프로젝트 소스 디렉토리 </em> 아래에 있습니다.:</p>
<ul>
<li><strong>docs/</strong> - 응용 프로그램 설명서는 어떤 형식으로 개발팀이 사용하고 있습니다.<br/><br/></li>
<li><strong>src/</strong> - Java 소스 서블릿, Bean 및 응용 프로그램 별 다른 Java 클래스를 생성한 파일입니다.
    당신의 소스 코드 패키지가 (<strong> highly </strong> 권장) 로 구성되어있는 경우, 패키지 계층이 디렉토리 아래에 디렉토리 구조에 반영되어야 합니다.<br/><br/></li>
<li><strong>web/</strong> - Web 사이트의 정적 콘텐츠는 (HTML 페이지, JSP 페이지, Java 스크립트 파일, CSS 스타일 시트 파일, 이미지), 응용 프로그램 클라이언트에 액세스 할 수 있습니다.이 디렉토리는 <em> 문서 루트 </em>는 Web 응용 프로그램 및 모든 하위 디렉토리 구조는 URI가 해당 파일에 액세스하는 데 필요한 요구에도 반영됩니다.<br/><br/></li>
<li><strong>web/WEB-INF/</strong> - Web 응용 프로그램 배포 설명자 (같은 응용 프로그램에 필요한 특수 설정 파일 <code> web.xml </code> 는 <a href = "http://wiki.apache.org/tomcat/Specifications"> 서블릿 사양 </a>, 커스텀 태그 라이브러리 및 당신의 Web 응용 프로그램에 포함할 다른 리소스 파일의 태그 라이브러리 디스크립터입니다. 이 디렉토리는 <em> 문서 루트의 하위 디렉토리인 것으로 보임에도 불구하고 </em>는 서블릿 사양 클라이언트 요청에 직접이 디렉토리의 내용 (또는 여기에 포함된 모든 파일) 의 이동을 금지합니다. 따라서 이것은 (데이터베이스 연결 아이디와 비밀번호 등)의 영향을 받기 쉽고, 구성 정보를 저장하기에 좋은 장소입니다. 또한, 성공적으로 실행되는 응용 프로그램에 필요합니다.</li>
</ul>

<p>프로그램이 개발되고 있는 동안에 두 추가 디렉토리가 일시적으로 생성됩니다.:</p>
<ul>
<li><strong>build/</strong> - 기본을 실행하면 빌드 (<code> ant </code>)에는 이 디렉토리에 있는 응용 프로그램의 Web 애플리케이션 아카이브 파일의 정확한 이미지가 포함되어 있습니다. Tomcat은 당신이 <code> $CATALINA_BASE/webapps </code> 디렉토리 또는 <em> installing </em>는 "관리자"를 통해 웹 응용 프로그램으로 복사하거나 이러한 압축을 푼 디렉토리에 응용 프로그램을 배포 할 수 있습니다. 후자의 방식은 개발 시에 매우 유용하며, 다음 내용에서 이에 대한 설명을 하겠습니다.
    <br/><br/></li>
<li><strong>dist/</strong> - 당신의 <code> dist </code> 타겟을 실행하면 해당 디렉토리가 생성됩니다. 당신이 준비한 라이센스 정보 문서 및 README 파일을 포함하여 Web 응용 프로그램의 바이너리 디스트리뷰션의 정확한 이미지를 만듭니다.</li>
</ul>

<p>이 두 디렉토리가 필요가 있다는 점에 유의하십시오. <strong>NOT</strong> 이들은 제거되고 다시 생성되지 않기 때문에 개발 중에 필요한 경우, 소스 코드 관리 시스템에 보관하여야 합니다. 사용자는 변경이 빌드가 실행되는 다음에 소실되므로 변경 사항을 영구 기록을 유지하고 싶다면 이러한 디렉토리 내의 모든 소스 파일을 편집하지 마십시오.</p>

  <subsection name="External Dependencies">

  <p>당신의 응용 프로그램이 외부 프로젝트 및 패키지에서 JAR 파일을 (또는 다른 자원)을 필요로하는 경우에 당신은 무엇을 하시겠습니까? 일반적인 예제에서는 작동하기 위해 Web 응용 프로그램은 JDBC 드라이버를 포함해야한다는 것입니다.</p>

  <p>다른 개발자는 이 문제에 대한 다른 접근 방식을 취한다.
  일부는 당신이 그 JAR 파일을 필요로하는 모든 응용 프로그램의 소스 코드 제어 아카이브에 의존하는 JAR 파일의 복사본을 체크 장려한다. 당신은 많은 응용 프로그램에서 동일한 JAR을 사용할 때는이 중요한 경영상의 문제를 일으킬 수 있습니다. - 특히 그 JAR 파일의 다른 버전으로 업그레이드 해야될 때.</p>

  <p>따라서 이 메뉴얼에서는 <strong> NOT </strong> 당신의 애플리케이션의 소스 컨트롤 아카이브 내부에 의존하는 패키지의 복사본을 저장하지 않는 것이 좋습니다. 대신 외부 의존 관계가 있는 건물의 과정의 일부를 응용 프로그램으로 통합되어야한다. 그렇게 당신은 항상 당신의 응용 프로그램에 의존하는 JAR 파일의 버전이 변경 될 때마다 업데이트를 걱정하지 않고, 개발, 시스템 관리자가 이를 설치 한 위치에서 JAR 파일의 올바른 버전을 갖고 올 수 있습니다.</p>

  <p>이 예제에서는 Ant는 <code> build.xml </code> 파일은 우리가 빌드 속성을 정의하는 방법을 소개합니다. <em> build properties </em> 는 당신이 <code> build.xml </code>는 이러한 파일을 변경할 때 코드 변경 없이 복사되는 파일의 위치를 설정합니다. 특정 개발자에 의해 사용되는 빌드 속성은 응용 프로그램에 대해 정의된 또는 개발자의 홈 디렉토리에 저장되어있는 "표준"의 빌드 속성에 기본이 될 수 있습니다.</p>

  <p>종종 당신의 개발 시스템 관리자는 이미 <code> lib </code>는 Tomcat 디렉토리에 필요한 JAR 파일을 설치하는 것입니다. 이것이 실행되는 경우는 전혀 행동을 취하지 않아야합니다 - 예를 들면 <code> build.xml </code> 파일이 자동으로 이러한 파일이 포함되어 있는지를 컴파일 경로를 구축합니다.</p>

  </subsection>

</section>


<section name="Source Code Control">

<p>전에 언급했듯이, 그것은 매우 당신이 동시 버전 시스템 (CVS)과 같은 소스 코드 관리 시스템 관리 응용 프로그램을 구성하는 모든 소스 파일을 배치하는 것이 좋습니다. 이렇게 선택한 경우 소스 계층의 모든 디렉토리와 파일을 등록 해 저장해야한다. -- 그러나 생성된 파일에아무것 아무것도 없다. 바이너리 파일 (이미지 나 JAR 라이브러리)을 등록하려면 소스 코드 관리 시스템에 하십시오.</p>

<p>우리는 당신의 <code> bulid </code> 내용을 포함해서는 안됨 (앞 절의) 추천과 <code> DIST </code> 소스 코드 관리 시스템은 개발 프로세스에 의해 만들어진 디렉토리입니다. 이 디렉토리를 무시하도록 CVS에 지시하는 간단한 방법의 <code>라는 파일을 만드는 것입니다. CVS는 다음과 같은 내용으로 당신의 최상위 소스 디렉토리 </code>가 합니다. (선행 마침표에 주의):</p>
<source>
build
dist
build.properties
</source>

<p><code> build.properties </code>를 언급하는 이유는 여기에 만약 <a href = "processes.html"> process </a> 섹션에서 설명됩니다.</p>

<p>당신의 소스 코드 관리 환경에 대한 자세한 절차는 이 설명서의 범위를 초과합니다. 명령 줄 CVS 클라이언트를 사용하는 경우에는 다음 단계가 계속되고 있다.:</p>
<ul>
<li>소스 저장소에 저장되는 것으로 소스 코드의 상태를 새로 고치려면 프로젝트의 소스 디렉토리로 이동하고 <code> CVS 업데이트-DP </code>를 실행하십시오.
    <br/><br/></li>
<li>소스 코드 계층의 새로운 하위 디렉토리를 만들 때의 <code> cvs add {하위 디렉토리 이름}의 </code>과 같은 명령을 사용하여 CVS에 등록.
    <br/><br/></li>
<li>당신이 먼저 새로운 소스 코드 파일을 만들 때, 그것을 포함하는 디렉토리로 이동하여와 <code> CVS 추가 {파일 이름} </code>과 같은 명령을 사용하여 새 파일을 등록합니다 .
    <br/><br/></li>
<li>당신은 더 이상 특정 소스 코드 파일을 필요로 하지 않는 경우 저장되어있는 디렉토리로 이동하여 파일을 삭제합니다. 다음의 <code> CVS 삭제 {파일 이름} </code>과 같은 명령을 사용하여 CVS에서 그것을 해제합니다.
    <br/><br/></li>
<li>당신은 생성, 수정 및 소스 파일을 삭제하는 동안 변경 사항이 아직 서버 저장소에 반영되지 않는다. 그들의 현재 상태의 변경 사항을 저장하려면 프로젝트의 소스 디렉토리로 이동하여 <code> CVS가 </ code>를 커밋 실행합니다. 당신은 어떤 업데이트 된 소스 파일의 새로운 버전으로 저장됩니다. 당신이 지금 막 완료 한 변경에 대한 간략한 설명을 기술하도록 요구됩니다.</li>
</ul>

<p>CVS는 다른 소스 코드 관리 시스템과 마찬가지로 많은 추가 기능 (나중에 병합 할 수 여러 개발 브랜치에 대한 특정 자료를 파일을 태그하는 기능 및 지원 등) 있습니다. 만약 <a href = "introduction.html"> 처음 연결 및 참조를 참조하십시오.</p>

</section>


<section name="BUILD.XML Configuration File">

<p>우리는 <strong> ant </strong>를 사용하는 도구의 컴파일 뛰어난 흡습 Java 소스 코드 파일 및 배포 계층 만들기를 관리한다. Ant는 처리가 필요한 단계를 정의하는 <code> build.xml </code>가 불려 일반적 빌드 파일의 제어하에 실행한다.  이 파일은 소스 코드 계층의 최상위 디렉토리에 저장됩니다. 귀하의 소스 코드 관리 시스템에 체크인 해야합니다.</p>

<p>메이크 파일과 같은의 <code> build.xml </code> 파일 옵션 개발 활동을 (그런 당신은 처음부터 프로젝트를 빌드 할 수 있도록 관련 Javadoc 문서를 작성, 배포 홈 디렉토리를 삭제 하도록 지원하는 몇 가지 "목표"를 제공 </ code>에는 또는 Web 응용 프로그램 아카이브 파일을 생성하기 때문에 귀하의 응용 프로그램을 배포 할 수 있습니다. 잘 구성된 <code> build.xml </code> 파일은 개발자가 사용하도록 설계되어있는 목표를 설명하는 내부 문서가 포함되어 그 대표적이 내부적으로 사용된다. 프로젝트 문서를 표시하려면 Ant를 요청하는 것, <code> build.xml </code> 파일 및 유형을 포함하는 디렉토리로 변경합니다.:</p>
<source>
ant -projecthelp
</source>

<p>당신에게 유리한 출발을 주고, 만약 <a href = "build.xml.txt"> 기본 build.xml 파일 </a>을 사용하면 응용 프로그램의 프로젝트 소스 디렉토리로 지정하여 설치할 수 있고, 볼 수 있습니다. 이 파일에는 실행할 수 다양한 목표를 설명하는 주석이 포함되어 있습니다. 간단히 말하면 다음 표적은 일반적 제공입니다.:</p>
<ul>
<li><strong>clean</strong> - 이 대상을 제거하고 기존 <code>는 그들이 처음부터 다시 구축 할 수 있도록 </code>와 <code> DIST </code> 디렉토리를 구축합니다. 이것은 당신이 영향을 받는 모든 클래스를 재컴파일하지 않기 때문에 런타임에 문제가 소스 코드를 변경하지 않는 것을 보장 할 수 있습니다.
    <br/><br/></li>
<li><strong>compile</strong> - 이 목표는 이전의 컴파일이 수행된 이후 변경된 모든 소스 코드를 컴파일하는 데 사용됩니다. 결과 클래스 파일의 <code> 빌드 </ code> 하위 디렉토리 <code> WEB-INF/classes 디렉토리에 만들어집니다 </code> 디렉토리, Web 어플리케이션의 구조는 그들이 있다는 것을 필요와 위치를 정확하게 나타냅니다. 이 명령은 개발 과정에서 자주 실행되므로 일반적으로 간단한의 <code> ant </ code> 명령이 그것을 실행하도록 "기본" 대상으로하고 있습니다.
    <br/><br/></li>
<li><strong>all</strong> - 이 목표는의 <code> compile </code> 타겟이 계속 <code> clean </code> 대상을 실행하기 위한 지름길입니다. 따라서 당신이 무의식적으로 어떤 호환되지 않는 변경을 도입하지 않는 것을 보장하기 위해 전체 응용 프로그램을 다시 컴파일하는 것을 보장합니다.
    <br/><br/></li>
<li><strong>javadoc</strong> - 이 대상이 Web 어플리케이션의 Java 클래스의 Javadoc API 문서를 만듭니다. 예를 들어 <code> build.xml </code> 파일은 당신의 어플 분포에서 API 문서를 포함 전제로하고 있기 때문에 <code> DIST </code> 디렉토리의 하위 디렉토리에 문서를 생성 합니다. 당신은 일반적으로 모든 컴파일에서 Javadoc을 생성할 필요가 없으므로 이 대상은 일반 <code> dist </code>의 대상 대신의 <code> compile </code>가 대상 의존성입니다.
    <br/><br/></li>
<li><strong>dist</strong> - 이 목표는 모든 서류는 Java 클래스의 Javadoc 및 Web 어플리케이션 아카이브 (WAR)에 응용 프로그램을 설치하려는 시스템 관리자에게 전달되는 파일을 포함하는 응용 프로그램의 배포 디렉토리를 만듭니다. 이 목표는 또한 <code> deploy </code>는 대상에 의존하고 있기 때문에 Web 응용 프로그램 아카이브 또한 배포시에 포함 된 모든 외부 종속성을 주워 있습니다.</li>
</ul>

<p>Tomcat을 사용하여 Web 응용 프로그램의 인터랙티브 개발 및 테스트를 위해 다음 추가 대상이 정의되어 있습니다.:</p>
<ul>
<li><strong>install</strong> - 실행 및 테스트를 위해 당신이 개발하는 응용 프로그램이 즉시 사용할 수 있도록 현재 실행중인 Tomcat을 알린다. 이 작업은 다시 시작하도록 Tomcat을 필요로하지 않지만 Tomcat은 다시 시작한 후, 그것은 또한 저장되지 않습니다.
    <br/><br/></li>
<li><strong>reload</strong> - 일단 응용 프로그램이 설치되어 변경할 <code> compile </code> 타겟을 사용하여 다시 컴파일 계속할 수 있습니다.  Tomcat은 자동으로 JSP 페이지에 변경 내용을 인식하지 서블릿 또는 JavaBean의 클래스가됩니다 - 이 명령은 이러한 변경 사항을 인식하도록 현재 설치되어있는 응용 프로그램을 다시 시작 Tomcat을 알려드립니다.
    <br/><br/></li>
<li><strong>remove</strong> - 당신은 개발 및 테스트 작업을 완료한 후, 필요에 따라 서비스에서 이 응용 프로그램을 제거하려면 Tomcat을 알 수 있습니다.
    </li>
</ul>

<p>개발 및 테스트 대상을 사용하면 다음 페이지에서 설명된 일부를 한 번만 설치하면 됩니다.</p>

</section>


</body>
</document>
